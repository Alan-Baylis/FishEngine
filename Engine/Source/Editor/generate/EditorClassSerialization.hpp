
/**************************************************
* auto generated by reflection system
**************************************************/

#include "../AssetImporter.hpp"
#include "../TextureImporter.hpp"
#include "../ModelImporter.hpp"

namespace FishEditor
{

	// AssetImporter
	template<typename Archive>
	void Save ( Archive& archive, AssetImporter const & value )
	{
		archive << FishEngine::BaseClassWrapper<FishEngine::Object>(value);
	}

	template<typename Archive>
	void Load ( Archive& archive, AssetImporter & value )
	{
		archive >> FishEngine::BaseClassWrapper<FishEngine::Object>(value);
	}


	// TextureImporter
	template<typename Archive>
	void Save ( Archive& archive, TextureImporter const & value )
	{
		archive << FishEngine::BaseClassWrapper<AssetImporter>(value);
		archive << FishEngine::make_nvp("m_textureType", value.m_textureType); // FishEngine::TextureImporterType
		archive << FishEngine::make_nvp("m_textureShape", value.m_textureShape); // FishEngine::TextureImporterShape
		archive << FishEngine::make_nvp("m_filterMode", value.m_textureSettings.m_filterMode); // FishEngine::FilterMode
		archive << FishEngine::make_nvp("m_wrapMode", value.m_textureSettings.m_wrapMode); // FishEngine::TextureWrapMode
		archive << FishEngine::make_nvp("m_sRGBTexture", value.m_sRGBTexture); // bool
		archive << FishEngine::make_nvp("m_isReadable", value.m_isReadable); // bool
		archive << FishEngine::make_nvp("m_mipmapEnabled", value.m_mipmapEnabled); // bool
	}

	template<typename Archive>
	void Load ( Archive& archive, TextureImporter & value )
	{
		archive >> FishEngine::BaseClassWrapper<AssetImporter>(value);
		archive >> FishEngine::make_nvp("m_textureType", value.m_textureType); // FishEngine::TextureImporterType
		archive >> FishEngine::make_nvp("m_textureShape", value.m_textureShape); // FishEngine::TextureImporterShape
		archive >> make_nvp("m_filterMode", value.m_textureSettings.m_filterMode); // FishEngine::FilterMode
		archive >> make_nvp("m_wrapMode", value.m_textureSettings.m_wrapMode); // FishEngine::TextureWrapMode
		archive >> FishEngine::make_nvp("m_sRGBTexture", value.m_sRGBTexture); // bool
		archive >> FishEngine::make_nvp("m_isReadable", value.m_isReadable); // bool
		archive >> FishEngine::make_nvp("m_mipmapEnabled", value.m_mipmapEnabled); // bool
	}


	// ModelImporter
	template<typename Archive>
	void Save ( Archive& archive, ModelImporter const & value )
	{
		archive << FishEngine::BaseClassWrapper<AssetImporter>(value);
		archive << FishEngine::make_nvp("m_fileScale", value.m_fileScale); // float
		archive << FishEngine::make_nvp("m_importNormals", value.m_importNormals); // FishEngine::ModelImporterNormals
		archive << FishEngine::make_nvp("m_importTangents", value.m_importTangents); // FishEngine::ModelImporterTangents
		archive << FishEngine::make_nvp("m_materialSearch", value.m_materialSearch); // FishEngine::ModelImporterMaterialSearch
	}

	template<typename Archive>
	void Load ( Archive& archive, ModelImporter & value )
	{
		archive >> FishEngine::BaseClassWrapper<AssetImporter>(value);
		archive >> FishEngine::make_nvp("m_fileScale", value.m_fileScale); // float
		archive >> FishEngine::make_nvp("m_importNormals", value.m_importNormals); // FishEngine::ModelImporterNormals
		archive >> FishEngine::make_nvp("m_importTangents", value.m_importTangents); // FishEngine::ModelImporterTangents
		archive >> FishEngine::make_nvp("m_materialSearch", value.m_materialSearch); // FishEngine::ModelImporterMaterialSearch
	}

} // namespace FishEngine

namespace FishEngine
{
    template<class Archive>
    static void DynamicSerializeEditorObject(Archive & archive, std::shared_ptr<Object> obj)
    {
        const int id = obj->ClassID();
        switch (id)
        {
        case ClassID<FishEditor::AssetImporter>():
            archive << *std::dynamic_pointer_cast<FishEditor::AssetImporter>(obj);
            break;
        case ClassID<FishEditor::TextureImporter>():
            archive << *std::dynamic_pointer_cast<FishEditor::TextureImporter>(obj);
            break;
        case ClassID<FishEditor::ModelImporter>():
            archive << *std::dynamic_pointer_cast<FishEditor::ModelImporter>(obj);
            break;
        default:
            abort();
        }
    }
}
