
/**************************************************
* auto generated by reflection system
**************************************************/

#include <Archive.hpp>
#include <private/CloneUtility.hpp>
#include "../Ray.hpp" 
#include "../Animator.hpp" 
#include "../Animator.hpp" 
#include "../Quaternion.hpp" 
#include "../Object.hpp" 
#include "../Collider.hpp" 
#include "../Animator.hpp" 
#include "../CameraController.hpp" 
#include "../Material.hpp" 
#include "../ShaderCompiler.hpp" 
#include "../MeshFilter.hpp" 
#include "../BoxCollider.hpp" 
#include "../Animator.hpp" 
#include "../Texture.hpp" 
#include "../Shader.hpp" 
#include "../Texture.hpp" 
#include "../Matrix4x4.hpp" 
#include "../Rigidbody.hpp" 
#include "../Animator.hpp" 
#include "../Component.hpp" 
#include "../Behaviour.hpp" 
#include "../Skybox.hpp" 
#include "../ShaderProperty.hpp" 
#include "../CapsuleCollider.hpp" 
#include "../Mesh.hpp" 
#include "../Renderer.hpp" 
#include "../Animator.hpp" 
#include "../Material.hpp" 
#include "../SkinnedMeshRenderer.hpp" 
#include "../SphereCollider.hpp" 
#include "../Mesh.hpp" 
#include "../Vector2.hpp" 
#include "../Vector3.hpp" 
#include "../Vector4.hpp" 
#include "../Bounds.hpp" 
#include "../ShaderProperty.hpp" 
#include "../Color.hpp" 
#include "../Light.hpp" 
#include "../Texture2D.hpp" 
#include "../Avatar.hpp" 
#include "../Script.hpp" 
#include "../IntVector.hpp" 
#include "../Frustum.hpp" 
#include "../IntVector.hpp" 
#include "../IntVector.hpp" 
#include "../Camera.hpp" 
#include "../Scene.hpp" 
#include "../MeshRenderer.hpp" 
#include "../Transform.hpp" 
#include "../GameObject.hpp" 

namespace FishEngine
{

	// FishEngine::Ray
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Ray const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("origin", value.origin); // FishEngine::Vector3
		archive << FishEngine::make_nvp("direction", value.direction); // FishEngine::Vector3
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Ray & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("origin", value.origin); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("direction", value.direction); // FishEngine::Vector3
		archive.EndClass();
		return archive;
	}

	// FishEngine::QuaternionKey
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::QuaternionKey const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("time", value.time); // float
		archive << FishEngine::make_nvp("value", value.value); // FishEngine::Quaternion
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::QuaternionKey & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("time", value.time); // float
		archive >> FishEngine::make_nvp("value", value.value); // FishEngine::Quaternion
		archive.EndClass();
		return archive;
	}

	// FishEngine::TransformationKey
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::TransformationKey const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("time", value.time); // float
		archive << FishEngine::make_nvp("value", value.value); // FishEngine::Matrix4x4
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::TransformationKey & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("time", value.time); // float
		archive >> FishEngine::make_nvp("value", value.value); // FishEngine::Matrix4x4
		archive.EndClass();
		return archive;
	}

	// FishEngine::Quaternion
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Quaternion const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("x", value.x); // float
		archive << FishEngine::make_nvp("y", value.y); // float
		archive << FishEngine::make_nvp("z", value.z); // float
		archive << FishEngine::make_nvp("w", value.w); // float
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Quaternion & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("x", value.x); // float
		archive >> FishEngine::make_nvp("y", value.y); // float
		archive >> FishEngine::make_nvp("z", value.z); // float
		archive >> FishEngine::make_nvp("w", value.w); // float
		archive.EndClass();
		return archive;
	}

	// FishEngine::Object
	void FishEngine::Object::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		archive << FishEngine::make_nvp("m_hideFlags", m_hideFlags); // FishEngine::HideFlags
		archive << FishEngine::make_nvp("m_name", m_name); // std::string
		//archive.EndClass();
	}

	void FishEngine::Object::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		archive >> FishEngine::make_nvp("m_hideFlags", m_hideFlags); // FishEngine::HideFlags
		archive >> FishEngine::make_nvp("m_name", m_name); // std::string
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Object::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Object>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::CloneUtility::Clone(this->m_hideFlags, ret->m_hideFlags); // FishEngine::HideFlags
		FishEngine::CloneUtility::Clone(this->m_name, ret->m_name); // std::string
		return ret;
	}

	void FishEngine::Object::CopyValueTo(ObjectPtr & target) const
	{
		auto ptr = std::dynamic_pointer_cast<FishEngine::Object>(target);
		FishEngine::CloneUtility::Clone(this->m_hideFlags, ptr->m_hideFlags); // FishEngine::HideFlags
		FishEngine::CloneUtility::Clone(this->m_name, ptr->m_name); // std::string
	}


	// FishEngine::Collider
	void FishEngine::Collider::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_contactOffset", m_contactOffset); // float
		archive << FishEngine::make_nvp("m_enabled", m_enabled); // bool
		archive << FishEngine::make_nvp("m_isTrigger", m_isTrigger); // bool
		//archive.EndClass();
	}

	void FishEngine::Collider::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_contactOffset", m_contactOffset); // float
		archive >> FishEngine::make_nvp("m_enabled", m_enabled); // bool
		archive >> FishEngine::make_nvp("m_isTrigger", m_isTrigger); // bool
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Collider::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Collider>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Component::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_contactOffset, ret->m_contactOffset); // float
		FishEngine::CloneUtility::Clone(this->m_enabled, ret->m_enabled); // bool
		FishEngine::CloneUtility::Clone(this->m_isTrigger, ret->m_isTrigger); // bool
		return ret;
	}

	void FishEngine::Collider::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Component::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Collider>(target);
		FishEngine::CloneUtility::Clone(this->m_contactOffset, ptr->m_contactOffset); // float
		FishEngine::CloneUtility::Clone(this->m_enabled, ptr->m_enabled); // bool
		FishEngine::CloneUtility::Clone(this->m_isTrigger, ptr->m_isTrigger); // bool
	}


	// FishEngine::Animator
	void FishEngine::Animator::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_time", m_time); // float
		archive << FishEngine::make_nvp("m_playing", m_playing); // bool
		archive << FishEngine::make_nvp("m_playingOnce", m_playingOnce); // bool
		archive << FishEngine::make_nvp("m_playOneFrame", m_playOneFrame); // bool
		archive << FishEngine::make_nvp("m_currentFrame", m_currentFrame); // int
		archive << FishEngine::make_nvp("m_avatar", m_avatar); // AvatarPtr
		archive << FishEngine::make_nvp("m_nameToGameObject", m_nameToGameObject); // std::map<std::string, std::weak_ptr<GameObject> >
		//archive.EndClass();
	}

	void FishEngine::Animator::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_time", m_time); // float
		archive >> FishEngine::make_nvp("m_playing", m_playing); // bool
		archive >> FishEngine::make_nvp("m_playingOnce", m_playingOnce); // bool
		archive >> FishEngine::make_nvp("m_playOneFrame", m_playOneFrame); // bool
		archive >> FishEngine::make_nvp("m_currentFrame", m_currentFrame); // int
		archive >> FishEngine::make_nvp("m_avatar", m_avatar); // AvatarPtr
		archive >> FishEngine::make_nvp("m_nameToGameObject", m_nameToGameObject); // std::map<std::string, std::weak_ptr<GameObject> >
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Animator::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Animator>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Component::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_time, ret->m_time); // float
		FishEngine::CloneUtility::Clone(this->m_playing, ret->m_playing); // bool
		FishEngine::CloneUtility::Clone(this->m_playingOnce, ret->m_playingOnce); // bool
		FishEngine::CloneUtility::Clone(this->m_playOneFrame, ret->m_playOneFrame); // bool
		FishEngine::CloneUtility::Clone(this->m_currentFrame, ret->m_currentFrame); // int
		FishEngine::CloneUtility::Clone(this->m_avatar, ret->m_avatar); // AvatarPtr
		FishEngine::CloneUtility::Clone(this->m_nameToGameObject, ret->m_nameToGameObject); // std::map<std::string, std::weak_ptr<GameObject> >
		return ret;
	}

	void FishEngine::Animator::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Component::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Animator>(target);
		FishEngine::CloneUtility::Clone(this->m_time, ptr->m_time); // float
		FishEngine::CloneUtility::Clone(this->m_playing, ptr->m_playing); // bool
		FishEngine::CloneUtility::Clone(this->m_playingOnce, ptr->m_playingOnce); // bool
		FishEngine::CloneUtility::Clone(this->m_playOneFrame, ptr->m_playOneFrame); // bool
		FishEngine::CloneUtility::Clone(this->m_currentFrame, ptr->m_currentFrame); // int
		FishEngine::CloneUtility::Clone(this->m_avatar, ptr->m_avatar); // AvatarPtr
		FishEngine::CloneUtility::Clone(this->m_nameToGameObject, ptr->m_nameToGameObject); // std::map<std::string, std::weak_ptr<GameObject> >
	}


	// FishEngine::CameraController
	void FishEngine::CameraController::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Script::Serialize(archive);
		archive << FishEngine::make_nvp("m_isRotating", m_isRotating); // bool
		archive << FishEngine::make_nvp("m_lookAtMode", m_lookAtMode); // bool
		archive << FishEngine::make_nvp("m_rotateSpeed", m_rotateSpeed); // float
		archive << FishEngine::make_nvp("m_dragSpeed", m_dragSpeed); // float
		archive << FishEngine::make_nvp("m_originalPosition", m_originalPosition); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_originalRotation", m_originalRotation); // FishEngine::Quaternion
		archive << FishEngine::make_nvp("m_originalScale", m_originalScale); // FishEngine::Vector3
		//archive.EndClass();
	}

	void FishEngine::CameraController::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Script::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_isRotating", m_isRotating); // bool
		archive >> FishEngine::make_nvp("m_lookAtMode", m_lookAtMode); // bool
		archive >> FishEngine::make_nvp("m_rotateSpeed", m_rotateSpeed); // float
		archive >> FishEngine::make_nvp("m_dragSpeed", m_dragSpeed); // float
		archive >> FishEngine::make_nvp("m_originalPosition", m_originalPosition); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_originalRotation", m_originalRotation); // FishEngine::Quaternion
		archive >> FishEngine::make_nvp("m_originalScale", m_originalScale); // FishEngine::Vector3
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::CameraController::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::CameraController>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Script::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_isRotating, ret->m_isRotating); // bool
		FishEngine::CloneUtility::Clone(this->m_lookAtMode, ret->m_lookAtMode); // bool
		FishEngine::CloneUtility::Clone(this->m_rotateSpeed, ret->m_rotateSpeed); // float
		FishEngine::CloneUtility::Clone(this->m_dragSpeed, ret->m_dragSpeed); // float
		FishEngine::CloneUtility::Clone(this->m_originalPosition, ret->m_originalPosition); // FishEngine::Vector3
		FishEngine::CloneUtility::Clone(this->m_originalRotation, ret->m_originalRotation); // FishEngine::Quaternion
		FishEngine::CloneUtility::Clone(this->m_originalScale, ret->m_originalScale); // FishEngine::Vector3
		return ret;
	}

	void FishEngine::CameraController::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Script::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::CameraController>(target);
		FishEngine::CloneUtility::Clone(this->m_isRotating, ptr->m_isRotating); // bool
		FishEngine::CloneUtility::Clone(this->m_lookAtMode, ptr->m_lookAtMode); // bool
		FishEngine::CloneUtility::Clone(this->m_rotateSpeed, ptr->m_rotateSpeed); // float
		FishEngine::CloneUtility::Clone(this->m_dragSpeed, ptr->m_dragSpeed); // float
		FishEngine::CloneUtility::Clone(this->m_originalPosition, ptr->m_originalPosition); // FishEngine::Vector3
		FishEngine::CloneUtility::Clone(this->m_originalRotation, ptr->m_originalRotation); // FishEngine::Quaternion
		FishEngine::CloneUtility::Clone(this->m_originalScale, ptr->m_originalScale); // FishEngine::Vector3
	}


	// FishEngine::Material
	void FishEngine::Material::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_shader", m_shader); // ShaderPtr
		archive << FishEngine::make_nvp("m_textures", m_textures); // std::map<std::string, TexturePtr>
		archive << FishEngine::make_nvp("m_uniforms", m_uniforms); // FishEngine::ShaderUniforms
		archive << FishEngine::make_nvp("m_properties", m_properties); // std::vector<MaterialProperty>
		//archive.EndClass();
	}

	void FishEngine::Material::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_shader", m_shader); // ShaderPtr
		archive >> FishEngine::make_nvp("m_textures", m_textures); // std::map<std::string, TexturePtr>
		archive >> FishEngine::make_nvp("m_uniforms", m_uniforms); // FishEngine::ShaderUniforms
		archive >> FishEngine::make_nvp("m_properties", m_properties); // std::vector<MaterialProperty>
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Material::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Material>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Object::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_shader, ret->m_shader); // ShaderPtr
		FishEngine::CloneUtility::Clone(this->m_textures, ret->m_textures); // std::map<std::string, TexturePtr>
		FishEngine::CloneUtility::Clone(this->m_uniforms, ret->m_uniforms); // FishEngine::ShaderUniforms
		FishEngine::CloneUtility::Clone(this->m_properties, ret->m_properties); // std::vector<MaterialProperty>
		return ret;
	}

	void FishEngine::Material::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Object::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Material>(target);
		FishEngine::CloneUtility::Clone(this->m_shader, ptr->m_shader); // ShaderPtr
		FishEngine::CloneUtility::Clone(this->m_textures, ptr->m_textures); // std::map<std::string, TexturePtr>
		FishEngine::CloneUtility::Clone(this->m_uniforms, ptr->m_uniforms); // FishEngine::ShaderUniforms
		FishEngine::CloneUtility::Clone(this->m_properties, ptr->m_properties); // std::vector<MaterialProperty>
	}


	// FishEngine::ShaderCompiler
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::ShaderCompiler const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("m_hasGeometryShader", value.m_hasGeometryShader); // bool
		archive << FishEngine::make_nvp("m_settings", value.m_settings); // std::map<std::string, std::string>
		archive << FishEngine::make_nvp("m_error", value.m_error); // FishEngine::ShaderCompilerErrorCode
		archive << FishEngine::make_nvp("m_errorString", value.m_errorString); // std::string
		archive << FishEngine::make_nvp("m_path", value.m_path); // Path
		archive << FishEngine::make_nvp("m_includeDepth", value.m_includeDepth); // uint32_t
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::ShaderCompiler & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("m_hasGeometryShader", value.m_hasGeometryShader); // bool
		archive >> FishEngine::make_nvp("m_settings", value.m_settings); // std::map<std::string, std::string>
		archive >> FishEngine::make_nvp("m_error", value.m_error); // FishEngine::ShaderCompilerErrorCode
		archive >> FishEngine::make_nvp("m_errorString", value.m_errorString); // std::string
		archive >> FishEngine::make_nvp("m_path", value.m_path); // Path
		archive >> FishEngine::make_nvp("m_includeDepth", value.m_includeDepth); // uint32_t
		archive.EndClass();
		return archive;
	}

	// FishEngine::MeshFilter
	void FishEngine::MeshFilter::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_mesh", m_mesh); // MeshPtr
		//archive.EndClass();
	}

	void FishEngine::MeshFilter::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_mesh", m_mesh); // MeshPtr
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::MeshFilter::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::MeshFilter>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Component::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_mesh, ret->m_mesh); // MeshPtr
		return ret;
	}

	void FishEngine::MeshFilter::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Component::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::MeshFilter>(target);
		FishEngine::CloneUtility::Clone(this->m_mesh, ptr->m_mesh); // MeshPtr
	}


	// FishEngine::BoxCollider
	void FishEngine::BoxCollider::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Collider::Serialize(archive);
		archive << FishEngine::make_nvp("m_center", m_center); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_size", m_size); // FishEngine::Vector3
		//archive.EndClass();
	}

	void FishEngine::BoxCollider::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Collider::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_center", m_center); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_size", m_size); // FishEngine::Vector3
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::BoxCollider::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::BoxCollider>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Collider::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_center, ret->m_center); // FishEngine::Vector3
		FishEngine::CloneUtility::Clone(this->m_size, ret->m_size); // FishEngine::Vector3
		return ret;
	}

	void FishEngine::BoxCollider::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Collider::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::BoxCollider>(target);
		FishEngine::CloneUtility::Clone(this->m_center, ptr->m_center); // FishEngine::Vector3
		FishEngine::CloneUtility::Clone(this->m_size, ptr->m_size); // FishEngine::Vector3
	}


	// FishEngine::AnimationNode
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::AnimationNode const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("name", value.name); // std::string
		archive << FishEngine::make_nvp("positionKeys", value.positionKeys); // std::vector<Vector3Key>
		archive << FishEngine::make_nvp("rotationKeys", value.rotationKeys); // std::vector<QuaternionKey>
		archive << FishEngine::make_nvp("scalingKeys", value.scalingKeys); // std::vector<Vector3Key>
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::AnimationNode & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("name", value.name); // std::string
		archive >> FishEngine::make_nvp("positionKeys", value.positionKeys); // std::vector<Vector3Key>
		archive >> FishEngine::make_nvp("rotationKeys", value.rotationKeys); // std::vector<QuaternionKey>
		archive >> FishEngine::make_nvp("scalingKeys", value.scalingKeys); // std::vector<Vector3Key>
		archive.EndClass();
		return archive;
	}

	// FishEngine::Cubemap
	void FishEngine::Cubemap::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Texture::Serialize(archive);
		archive << FishEngine::make_nvp("m_format", m_format); // FishEngine::TextureFormat
		archive << FishEngine::make_nvp("m_mipmapCount", m_mipmapCount); // uint32_t
		//archive.EndClass();
	}

	void FishEngine::Cubemap::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Texture::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_format", m_format); // FishEngine::TextureFormat
		archive >> FishEngine::make_nvp("m_mipmapCount", m_mipmapCount); // uint32_t
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Cubemap::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Cubemap>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Texture::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_format, ret->m_format); // FishEngine::TextureFormat
		FishEngine::CloneUtility::Clone(this->m_mipmapCount, ret->m_mipmapCount); // uint32_t
		return ret;
	}

	void FishEngine::Cubemap::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Texture::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Cubemap>(target);
		FishEngine::CloneUtility::Clone(this->m_format, ptr->m_format); // FishEngine::TextureFormat
		FishEngine::CloneUtility::Clone(this->m_mipmapCount, ptr->m_mipmapCount); // uint32_t
	}


	// FishEngine::Shader
	void FishEngine::Shader::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_uniforms", m_uniforms); // std::vector<UniformInfo>
		archive << FishEngine::make_nvp("m_cullface", m_cullface); // FishEngine::Cullface
		archive << FishEngine::make_nvp("m_ZWrite", m_ZWrite); // bool
		archive << FishEngine::make_nvp("m_blend", m_blend); // bool
		archive << FishEngine::make_nvp("m_deferred", m_deferred); // bool
		archive << FishEngine::make_nvp("m_keywords", m_keywords); // ShaderKeywords
		//archive.EndClass();
	}

	void FishEngine::Shader::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_uniforms", m_uniforms); // std::vector<UniformInfo>
		archive >> FishEngine::make_nvp("m_cullface", m_cullface); // FishEngine::Cullface
		archive >> FishEngine::make_nvp("m_ZWrite", m_ZWrite); // bool
		archive >> FishEngine::make_nvp("m_blend", m_blend); // bool
		archive >> FishEngine::make_nvp("m_deferred", m_deferred); // bool
		archive >> FishEngine::make_nvp("m_keywords", m_keywords); // ShaderKeywords
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Shader::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Shader>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Object::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_uniforms, ret->m_uniforms); // std::vector<UniformInfo>
		FishEngine::CloneUtility::Clone(this->m_cullface, ret->m_cullface); // FishEngine::Cullface
		FishEngine::CloneUtility::Clone(this->m_ZWrite, ret->m_ZWrite); // bool
		FishEngine::CloneUtility::Clone(this->m_blend, ret->m_blend); // bool
		FishEngine::CloneUtility::Clone(this->m_deferred, ret->m_deferred); // bool
		FishEngine::CloneUtility::Clone(this->m_keywords, ret->m_keywords); // ShaderKeywords
		return ret;
	}

	void FishEngine::Shader::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Object::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Shader>(target);
		FishEngine::CloneUtility::Clone(this->m_uniforms, ptr->m_uniforms); // std::vector<UniformInfo>
		FishEngine::CloneUtility::Clone(this->m_cullface, ptr->m_cullface); // FishEngine::Cullface
		FishEngine::CloneUtility::Clone(this->m_ZWrite, ptr->m_ZWrite); // bool
		FishEngine::CloneUtility::Clone(this->m_blend, ptr->m_blend); // bool
		FishEngine::CloneUtility::Clone(this->m_deferred, ptr->m_deferred); // bool
		FishEngine::CloneUtility::Clone(this->m_keywords, ptr->m_keywords); // ShaderKeywords
	}


	// FishEngine::Texture
	void FishEngine::Texture::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_height", m_height); // uint32_t
		archive << FishEngine::make_nvp("m_width", m_width); // uint32_t
		archive << FishEngine::make_nvp("m_anisoLevel", m_anisoLevel); // int
		archive << FishEngine::make_nvp("m_dimension", m_dimension); // FishEngine::TextureDimension
		archive << FishEngine::make_nvp("m_filterMode", m_filterMode); // FishEngine::FilterMode
		archive << FishEngine::make_nvp("m_wrapMode", m_wrapMode); // FishEngine::TextureWrapMode
		//archive.EndClass();
	}

	void FishEngine::Texture::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_height", m_height); // uint32_t
		archive >> FishEngine::make_nvp("m_width", m_width); // uint32_t
		archive >> FishEngine::make_nvp("m_anisoLevel", m_anisoLevel); // int
		archive >> FishEngine::make_nvp("m_dimension", m_dimension); // FishEngine::TextureDimension
		archive >> FishEngine::make_nvp("m_filterMode", m_filterMode); // FishEngine::FilterMode
		archive >> FishEngine::make_nvp("m_wrapMode", m_wrapMode); // FishEngine::TextureWrapMode
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Texture::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Texture>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Object::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_height, ret->m_height); // uint32_t
		FishEngine::CloneUtility::Clone(this->m_width, ret->m_width); // uint32_t
		FishEngine::CloneUtility::Clone(this->m_anisoLevel, ret->m_anisoLevel); // int
		FishEngine::CloneUtility::Clone(this->m_dimension, ret->m_dimension); // FishEngine::TextureDimension
		FishEngine::CloneUtility::Clone(this->m_filterMode, ret->m_filterMode); // FishEngine::FilterMode
		FishEngine::CloneUtility::Clone(this->m_wrapMode, ret->m_wrapMode); // FishEngine::TextureWrapMode
		return ret;
	}

	void FishEngine::Texture::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Object::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Texture>(target);
		FishEngine::CloneUtility::Clone(this->m_height, ptr->m_height); // uint32_t
		FishEngine::CloneUtility::Clone(this->m_width, ptr->m_width); // uint32_t
		FishEngine::CloneUtility::Clone(this->m_anisoLevel, ptr->m_anisoLevel); // int
		FishEngine::CloneUtility::Clone(this->m_dimension, ptr->m_dimension); // FishEngine::TextureDimension
		FishEngine::CloneUtility::Clone(this->m_filterMode, ptr->m_filterMode); // FishEngine::FilterMode
		FishEngine::CloneUtility::Clone(this->m_wrapMode, ptr->m_wrapMode); // FishEngine::TextureWrapMode
	}


	// FishEngine::Matrix4x4
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Matrix4x4 const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("rows[0]", value.rows[0]); // FishEngine::Vector4
		archive << FishEngine::make_nvp("rows[1]", value.rows[1]); // FishEngine::Vector4
		archive << FishEngine::make_nvp("rows[2]", value.rows[2]); // FishEngine::Vector4
		archive << FishEngine::make_nvp("rows[3]", value.rows[3]); // FishEngine::Vector4
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Matrix4x4 & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("rows[0]", value.rows[0]); // FishEngine::Vector4
		archive >> FishEngine::make_nvp("rows[1]", value.rows[1]); // FishEngine::Vector4
		archive >> FishEngine::make_nvp("rows[2]", value.rows[2]); // FishEngine::Vector4
		archive >> FishEngine::make_nvp("rows[3]", value.rows[3]); // FishEngine::Vector4
		archive.EndClass();
		return archive;
	}

	// FishEngine::Rigidbody
	void FishEngine::Rigidbody::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_mass", m_mass); // float
		archive << FishEngine::make_nvp("m_drag", m_drag); // float
		archive << FishEngine::make_nvp("m_angularDrag", m_angularDrag); // float
		archive << FishEngine::make_nvp("m_useGravity", m_useGravity); // bool
		archive << FishEngine::make_nvp("m_isKinematic", m_isKinematic); // bool
		archive << FishEngine::make_nvp("m_velocity", m_velocity); // FishEngine::Vector3
		//archive.EndClass();
	}

	void FishEngine::Rigidbody::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_mass", m_mass); // float
		archive >> FishEngine::make_nvp("m_drag", m_drag); // float
		archive >> FishEngine::make_nvp("m_angularDrag", m_angularDrag); // float
		archive >> FishEngine::make_nvp("m_useGravity", m_useGravity); // bool
		archive >> FishEngine::make_nvp("m_isKinematic", m_isKinematic); // bool
		archive >> FishEngine::make_nvp("m_velocity", m_velocity); // FishEngine::Vector3
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Rigidbody::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Rigidbody>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Component::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_mass, ret->m_mass); // float
		FishEngine::CloneUtility::Clone(this->m_drag, ret->m_drag); // float
		FishEngine::CloneUtility::Clone(this->m_angularDrag, ret->m_angularDrag); // float
		FishEngine::CloneUtility::Clone(this->m_useGravity, ret->m_useGravity); // bool
		FishEngine::CloneUtility::Clone(this->m_isKinematic, ret->m_isKinematic); // bool
		FishEngine::CloneUtility::Clone(this->m_velocity, ret->m_velocity); // FishEngine::Vector3
		return ret;
	}

	void FishEngine::Rigidbody::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Component::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Rigidbody>(target);
		FishEngine::CloneUtility::Clone(this->m_mass, ptr->m_mass); // float
		FishEngine::CloneUtility::Clone(this->m_drag, ptr->m_drag); // float
		FishEngine::CloneUtility::Clone(this->m_angularDrag, ptr->m_angularDrag); // float
		FishEngine::CloneUtility::Clone(this->m_useGravity, ptr->m_useGravity); // bool
		FishEngine::CloneUtility::Clone(this->m_isKinematic, ptr->m_isKinematic); // bool
		FishEngine::CloneUtility::Clone(this->m_velocity, ptr->m_velocity); // FishEngine::Vector3
	}


	// FishEngine::Vector3Key
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Vector3Key const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("time", value.time); // float
		archive << FishEngine::make_nvp("value", value.value); // FishEngine::Vector3
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Vector3Key & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("time", value.time); // float
		archive >> FishEngine::make_nvp("value", value.value); // FishEngine::Vector3
		archive.EndClass();
		return archive;
	}

	// FishEngine::Component
	void FishEngine::Component::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_gameObject", m_gameObject); // std::weak_ptr<GameObject>
		//archive.EndClass();
	}

	void FishEngine::Component::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_gameObject", m_gameObject); // std::weak_ptr<GameObject>
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Component::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Component>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Object::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_gameObject, ret->m_gameObject); // std::weak_ptr<GameObject>
		return ret;
	}

	void FishEngine::Component::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Object::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Component>(target);
		FishEngine::CloneUtility::Clone(this->m_gameObject, ptr->m_gameObject); // std::weak_ptr<GameObject>
	}


	// FishEngine::Behaviour
	void FishEngine::Behaviour::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_enabled", m_enabled); // bool
		//archive.EndClass();
	}

	void FishEngine::Behaviour::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_enabled", m_enabled); // bool
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Behaviour::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Behaviour>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Component::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_enabled, ret->m_enabled); // bool
		return ret;
	}

	void FishEngine::Behaviour::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Component::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Behaviour>(target);
		FishEngine::CloneUtility::Clone(this->m_enabled, ptr->m_enabled); // bool
	}


	// FishEngine::Skybox
	void FishEngine::Skybox::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Behaviour::Serialize(archive);
		archive << FishEngine::make_nvp("m_material", m_material); // MaterialPtr
		//archive.EndClass();
	}

	void FishEngine::Skybox::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Behaviour::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_material", m_material); // MaterialPtr
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Skybox::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Skybox>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Behaviour::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_material, ret->m_material); // MaterialPtr
		return ret;
	}

	void FishEngine::Skybox::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Behaviour::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Skybox>(target);
		FishEngine::CloneUtility::Clone(this->m_material, ptr->m_material); // MaterialPtr
	}


	// FishEngine::ShaderUniforms
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::ShaderUniforms const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("mat4s", value.mat4s); // std::map<std::string, Matrix4x4>
		archive << FishEngine::make_nvp("vec2s", value.vec2s); // std::map<std::string, Vector2>
		archive << FishEngine::make_nvp("vec3s", value.vec3s); // std::map<std::string, Vector3>
		archive << FishEngine::make_nvp("vec4s", value.vec4s); // std::map<std::string, Vector4>
		archive << FishEngine::make_nvp("floats", value.floats); // std::map<std::string, float>
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::ShaderUniforms & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("mat4s", value.mat4s); // std::map<std::string, Matrix4x4>
		archive >> FishEngine::make_nvp("vec2s", value.vec2s); // std::map<std::string, Vector2>
		archive >> FishEngine::make_nvp("vec3s", value.vec3s); // std::map<std::string, Vector3>
		archive >> FishEngine::make_nvp("vec4s", value.vec4s); // std::map<std::string, Vector4>
		archive >> FishEngine::make_nvp("floats", value.floats); // std::map<std::string, float>
		archive.EndClass();
		return archive;
	}

	// FishEngine::CapsuleCollider
	void FishEngine::CapsuleCollider::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Collider::Serialize(archive);
		archive << FishEngine::make_nvp("m_center", m_center); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_direction", m_direction); // int
		archive << FishEngine::make_nvp("m_height", m_height); // float
		archive << FishEngine::make_nvp("m_radius", m_radius); // float
		//archive.EndClass();
	}

	void FishEngine::CapsuleCollider::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Collider::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_center", m_center); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_direction", m_direction); // int
		archive >> FishEngine::make_nvp("m_height", m_height); // float
		archive >> FishEngine::make_nvp("m_radius", m_radius); // float
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::CapsuleCollider::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::CapsuleCollider>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Collider::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_center, ret->m_center); // FishEngine::Vector3
		FishEngine::CloneUtility::Clone(this->m_direction, ret->m_direction); // int
		FishEngine::CloneUtility::Clone(this->m_height, ret->m_height); // float
		FishEngine::CloneUtility::Clone(this->m_radius, ret->m_radius); // float
		return ret;
	}

	void FishEngine::CapsuleCollider::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Collider::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::CapsuleCollider>(target);
		FishEngine::CloneUtility::Clone(this->m_center, ptr->m_center); // FishEngine::Vector3
		FishEngine::CloneUtility::Clone(this->m_direction, ptr->m_direction); // int
		FishEngine::CloneUtility::Clone(this->m_height, ptr->m_height); // float
		FishEngine::CloneUtility::Clone(this->m_radius, ptr->m_radius); // float
	}


	// FishEngine::Mesh
	void FishEngine::Mesh::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_skinned", m_skinned); // bool
		archive << FishEngine::make_nvp("m_vertices", m_vertices); // std::vector<Vector3>
		archive << FishEngine::make_nvp("m_normals", m_normals); // std::vector<Vector3>
		archive << FishEngine::make_nvp("m_uv", m_uv); // std::vector<Vector2>
		archive << FishEngine::make_nvp("m_tangents", m_tangents); // std::vector<Vector3>
		archive << FishEngine::make_nvp("m_triangles", m_triangles); // std::vector<uint32_t>
		archive << FishEngine::make_nvp("m_bindposes", m_bindposes); // std::vector<Matrix4x4>
		archive << FishEngine::make_nvp("m_boneNames", m_boneNames); // std::vector<std::string>
		archive << FishEngine::make_nvp("m_bones", m_bones); // std::vector<std::weak_ptr<Transform> >
		archive << FishEngine::make_nvp("m_isReadable", m_isReadable); // bool
		archive << FishEngine::make_nvp("m_uploaded", m_uploaded); // bool
		archive << FishEngine::make_nvp("m_vertexCount", m_vertexCount); // uint32_t
		archive << FishEngine::make_nvp("m_triangleCount", m_triangleCount); // uint32_t
		archive << FishEngine::make_nvp("m_bounds", m_bounds); // FishEngine::Bounds
		//archive.EndClass();
	}

	void FishEngine::Mesh::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_skinned", m_skinned); // bool
		archive >> FishEngine::make_nvp("m_vertices", m_vertices); // std::vector<Vector3>
		archive >> FishEngine::make_nvp("m_normals", m_normals); // std::vector<Vector3>
		archive >> FishEngine::make_nvp("m_uv", m_uv); // std::vector<Vector2>
		archive >> FishEngine::make_nvp("m_tangents", m_tangents); // std::vector<Vector3>
		archive >> FishEngine::make_nvp("m_triangles", m_triangles); // std::vector<uint32_t>
		archive >> FishEngine::make_nvp("m_bindposes", m_bindposes); // std::vector<Matrix4x4>
		archive >> FishEngine::make_nvp("m_boneNames", m_boneNames); // std::vector<std::string>
		archive >> FishEngine::make_nvp("m_bones", m_bones); // std::vector<std::weak_ptr<Transform> >
		archive >> FishEngine::make_nvp("m_isReadable", m_isReadable); // bool
		archive >> FishEngine::make_nvp("m_uploaded", m_uploaded); // bool
		archive >> FishEngine::make_nvp("m_vertexCount", m_vertexCount); // uint32_t
		archive >> FishEngine::make_nvp("m_triangleCount", m_triangleCount); // uint32_t
		archive >> FishEngine::make_nvp("m_bounds", m_bounds); // FishEngine::Bounds
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Mesh::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Mesh>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Object::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_skinned, ret->m_skinned); // bool
		FishEngine::CloneUtility::Clone(this->m_vertices, ret->m_vertices); // std::vector<Vector3>
		FishEngine::CloneUtility::Clone(this->m_normals, ret->m_normals); // std::vector<Vector3>
		FishEngine::CloneUtility::Clone(this->m_uv, ret->m_uv); // std::vector<Vector2>
		FishEngine::CloneUtility::Clone(this->m_tangents, ret->m_tangents); // std::vector<Vector3>
		FishEngine::CloneUtility::Clone(this->m_triangles, ret->m_triangles); // std::vector<uint32_t>
		FishEngine::CloneUtility::Clone(this->m_bindposes, ret->m_bindposes); // std::vector<Matrix4x4>
		FishEngine::CloneUtility::Clone(this->m_boneNames, ret->m_boneNames); // std::vector<std::string>
		FishEngine::CloneUtility::Clone(this->m_bones, ret->m_bones); // std::vector<std::weak_ptr<Transform> >
		FishEngine::CloneUtility::Clone(this->m_isReadable, ret->m_isReadable); // bool
		FishEngine::CloneUtility::Clone(this->m_uploaded, ret->m_uploaded); // bool
		FishEngine::CloneUtility::Clone(this->m_vertexCount, ret->m_vertexCount); // uint32_t
		FishEngine::CloneUtility::Clone(this->m_triangleCount, ret->m_triangleCount); // uint32_t
		FishEngine::CloneUtility::Clone(this->m_bounds, ret->m_bounds); // FishEngine::Bounds
		return ret;
	}

	void FishEngine::Mesh::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Object::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Mesh>(target);
		FishEngine::CloneUtility::Clone(this->m_skinned, ptr->m_skinned); // bool
		FishEngine::CloneUtility::Clone(this->m_vertices, ptr->m_vertices); // std::vector<Vector3>
		FishEngine::CloneUtility::Clone(this->m_normals, ptr->m_normals); // std::vector<Vector3>
		FishEngine::CloneUtility::Clone(this->m_uv, ptr->m_uv); // std::vector<Vector2>
		FishEngine::CloneUtility::Clone(this->m_tangents, ptr->m_tangents); // std::vector<Vector3>
		FishEngine::CloneUtility::Clone(this->m_triangles, ptr->m_triangles); // std::vector<uint32_t>
		FishEngine::CloneUtility::Clone(this->m_bindposes, ptr->m_bindposes); // std::vector<Matrix4x4>
		FishEngine::CloneUtility::Clone(this->m_boneNames, ptr->m_boneNames); // std::vector<std::string>
		FishEngine::CloneUtility::Clone(this->m_bones, ptr->m_bones); // std::vector<std::weak_ptr<Transform> >
		FishEngine::CloneUtility::Clone(this->m_isReadable, ptr->m_isReadable); // bool
		FishEngine::CloneUtility::Clone(this->m_uploaded, ptr->m_uploaded); // bool
		FishEngine::CloneUtility::Clone(this->m_vertexCount, ptr->m_vertexCount); // uint32_t
		FishEngine::CloneUtility::Clone(this->m_triangleCount, ptr->m_triangleCount); // uint32_t
		FishEngine::CloneUtility::Clone(this->m_bounds, ptr->m_bounds); // FishEngine::Bounds
	}


	// FishEngine::Renderer
	void FishEngine::Renderer::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_enabled", m_enabled); // bool
		archive << FishEngine::make_nvp("m_materials", m_materials); // std::vector<MaterialPtr>
		archive << FishEngine::make_nvp("m_shadowCastingMode", m_shadowCastingMode); // FishEngine::ShadowCastingMode
		archive << FishEngine::make_nvp("m_receiveShadows", m_receiveShadows); // bool
		//archive.EndClass();
	}

	void FishEngine::Renderer::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_enabled", m_enabled); // bool
		archive >> FishEngine::make_nvp("m_materials", m_materials); // std::vector<MaterialPtr>
		archive >> FishEngine::make_nvp("m_shadowCastingMode", m_shadowCastingMode); // FishEngine::ShadowCastingMode
		archive >> FishEngine::make_nvp("m_receiveShadows", m_receiveShadows); // bool
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Renderer::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Renderer>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Component::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_enabled, ret->m_enabled); // bool
		FishEngine::CloneUtility::Clone(this->m_materials, ret->m_materials); // std::vector<MaterialPtr>
		FishEngine::CloneUtility::Clone(this->m_shadowCastingMode, ret->m_shadowCastingMode); // FishEngine::ShadowCastingMode
		FishEngine::CloneUtility::Clone(this->m_receiveShadows, ret->m_receiveShadows); // bool
		return ret;
	}

	void FishEngine::Renderer::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Component::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Renderer>(target);
		FishEngine::CloneUtility::Clone(this->m_enabled, ptr->m_enabled); // bool
		FishEngine::CloneUtility::Clone(this->m_materials, ptr->m_materials); // std::vector<MaterialPtr>
		FishEngine::CloneUtility::Clone(this->m_shadowCastingMode, ptr->m_shadowCastingMode); // FishEngine::ShadowCastingMode
		FishEngine::CloneUtility::Clone(this->m_receiveShadows, ptr->m_receiveShadows); // bool
	}


	// FishEngine::AnimationChannel
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::AnimationChannel const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("name", value.name); // std::string
		archive << FishEngine::make_nvp("duration", value.duration); // float
		archive << FishEngine::make_nvp("ticksPerSecond", value.ticksPerSecond); // float
		archive << FishEngine::make_nvp("channels", value.channels); // std::map<std::string, AnimationNode>
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::AnimationChannel & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("name", value.name); // std::string
		archive >> FishEngine::make_nvp("duration", value.duration); // float
		archive >> FishEngine::make_nvp("ticksPerSecond", value.ticksPerSecond); // float
		archive >> FishEngine::make_nvp("channels", value.channels); // std::map<std::string, AnimationNode>
		archive.EndClass();
		return archive;
	}

	// FishEngine::MaterialProperty
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::MaterialProperty const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("name", value.name); // std::string
		archive << FishEngine::make_nvp("type", value.type); // FishEngine::MaterialPropertyType
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::MaterialProperty & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("name", value.name); // std::string
		archive >> FishEngine::make_nvp("type", value.type); // FishEngine::MaterialPropertyType
		archive.EndClass();
		return archive;
	}

	// FishEngine::SkinnedMeshRenderer
	void FishEngine::SkinnedMeshRenderer::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Renderer::Serialize(archive);
		archive << FishEngine::make_nvp("m_sharedMesh", m_sharedMesh); // MeshPtr
		archive << FishEngine::make_nvp("m_avatar", m_avatar); // AvatarPtr
		archive << FishEngine::make_nvp("m_rootBone", m_rootBone); // std::weak_ptr<Transform>
		archive << FishEngine::make_nvp("m_bones", m_bones); // std::vector<std::weak_ptr<Transform> >
		//archive.EndClass();
	}

	void FishEngine::SkinnedMeshRenderer::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Renderer::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_sharedMesh", m_sharedMesh); // MeshPtr
		archive >> FishEngine::make_nvp("m_avatar", m_avatar); // AvatarPtr
		archive >> FishEngine::make_nvp("m_rootBone", m_rootBone); // std::weak_ptr<Transform>
		archive >> FishEngine::make_nvp("m_bones", m_bones); // std::vector<std::weak_ptr<Transform> >
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::SkinnedMeshRenderer::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::SkinnedMeshRenderer>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Renderer::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_sharedMesh, ret->m_sharedMesh); // MeshPtr
		FishEngine::CloneUtility::Clone(this->m_avatar, ret->m_avatar); // AvatarPtr
		FishEngine::CloneUtility::Clone(this->m_rootBone, ret->m_rootBone); // std::weak_ptr<Transform>
		FishEngine::CloneUtility::Clone(this->m_bones, ret->m_bones); // std::vector<std::weak_ptr<Transform> >
		return ret;
	}

	void FishEngine::SkinnedMeshRenderer::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Renderer::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::SkinnedMeshRenderer>(target);
		FishEngine::CloneUtility::Clone(this->m_sharedMesh, ptr->m_sharedMesh); // MeshPtr
		FishEngine::CloneUtility::Clone(this->m_avatar, ptr->m_avatar); // AvatarPtr
		FishEngine::CloneUtility::Clone(this->m_rootBone, ptr->m_rootBone); // std::weak_ptr<Transform>
		FishEngine::CloneUtility::Clone(this->m_bones, ptr->m_bones); // std::vector<std::weak_ptr<Transform> >
	}


	// FishEngine::SphereCollider
	void FishEngine::SphereCollider::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Collider::Serialize(archive);
		archive << FishEngine::make_nvp("m_center", m_center); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_radius", m_radius); // float
		//archive.EndClass();
	}

	void FishEngine::SphereCollider::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Collider::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_center", m_center); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_radius", m_radius); // float
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::SphereCollider::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::SphereCollider>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Collider::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_center, ret->m_center); // FishEngine::Vector3
		FishEngine::CloneUtility::Clone(this->m_radius, ret->m_radius); // float
		return ret;
	}

	void FishEngine::SphereCollider::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Collider::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::SphereCollider>(target);
		FishEngine::CloneUtility::Clone(this->m_center, ptr->m_center); // FishEngine::Vector3
		FishEngine::CloneUtility::Clone(this->m_radius, ptr->m_radius); // float
	}


	// FishEngine::BoneWeight
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::BoneWeight const & value )
	{
		archive.BeginClass();
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::BoneWeight & value )
	{
		archive.BeginClass();
		archive.EndClass();
		return archive;
	}

	// FishEngine::Vector2
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Vector2 const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("x", value.x); // float
		archive << FishEngine::make_nvp("y", value.y); // float
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Vector2 & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("x", value.x); // float
		archive >> FishEngine::make_nvp("y", value.y); // float
		archive.EndClass();
		return archive;
	}

	// FishEngine::Vector3
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Vector3 const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("x", value.x); // float
		archive << FishEngine::make_nvp("y", value.y); // float
		archive << FishEngine::make_nvp("z", value.z); // float
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Vector3 & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("x", value.x); // float
		archive >> FishEngine::make_nvp("y", value.y); // float
		archive >> FishEngine::make_nvp("z", value.z); // float
		archive.EndClass();
		return archive;
	}

	// FishEngine::Vector4
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Vector4 const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("x", value.x); // float
		archive << FishEngine::make_nvp("y", value.y); // float
		archive << FishEngine::make_nvp("z", value.z); // float
		archive << FishEngine::make_nvp("w", value.w); // float
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Vector4 & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("x", value.x); // float
		archive >> FishEngine::make_nvp("y", value.y); // float
		archive >> FishEngine::make_nvp("z", value.z); // float
		archive >> FishEngine::make_nvp("w", value.w); // float
		archive.EndClass();
		return archive;
	}

	// FishEngine::Bounds
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Bounds const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("m_center", value.m_center); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_extents", value.m_extents); // FishEngine::Vector3
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Bounds & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("m_center", value.m_center); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_extents", value.m_extents); // FishEngine::Vector3
		archive.EndClass();
		return archive;
	}

	// FishEngine::UniformInfo
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::UniformInfo const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("type", value.type); // GLenum
		archive << FishEngine::make_nvp("name", value.name); // std::string
		archive << FishEngine::make_nvp("location", value.location); // GLuint
		archive << FishEngine::make_nvp("textureBindPoint", value.textureBindPoint); // int
		archive << FishEngine::make_nvp("binded", value.binded); // bool
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::UniformInfo & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("type", value.type); // GLenum
		archive >> FishEngine::make_nvp("name", value.name); // std::string
		archive >> FishEngine::make_nvp("location", value.location); // GLuint
		archive >> FishEngine::make_nvp("textureBindPoint", value.textureBindPoint); // int
		archive >> FishEngine::make_nvp("binded", value.binded); // bool
		archive.EndClass();
		return archive;
	}

	// FishEngine::Color
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Color const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("r", value.r); // float
		archive << FishEngine::make_nvp("g", value.g); // float
		archive << FishEngine::make_nvp("b", value.b); // float
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Color & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("r", value.r); // float
		archive >> FishEngine::make_nvp("g", value.g); // float
		archive >> FishEngine::make_nvp("b", value.b); // float
		archive.EndClass();
		return archive;
	}

	// FishEngine::Light
	void FishEngine::Light::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Behaviour::Serialize(archive);
		archive << FishEngine::make_nvp("m_type", m_type); // FishEngine::LightType
		archive << FishEngine::make_nvp("m_range", m_range); // float
		archive << FishEngine::make_nvp("m_spotAngle", m_spotAngle); // float
		archive << FishEngine::make_nvp("m_color", m_color); // FishEngine::Color
		archive << FishEngine::make_nvp("m_intensity", m_intensity); // float
		archive << FishEngine::make_nvp("m_shadowBias", m_shadowBias); // float
		archive << FishEngine::make_nvp("m_shadowNormalBias", m_shadowNormalBias); // float
		archive << FishEngine::make_nvp("m_shadowNearPlane", m_shadowNearPlane); // float
		//archive.EndClass();
	}

	void FishEngine::Light::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Behaviour::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_type", m_type); // FishEngine::LightType
		archive >> FishEngine::make_nvp("m_range", m_range); // float
		archive >> FishEngine::make_nvp("m_spotAngle", m_spotAngle); // float
		archive >> FishEngine::make_nvp("m_color", m_color); // FishEngine::Color
		archive >> FishEngine::make_nvp("m_intensity", m_intensity); // float
		archive >> FishEngine::make_nvp("m_shadowBias", m_shadowBias); // float
		archive >> FishEngine::make_nvp("m_shadowNormalBias", m_shadowNormalBias); // float
		archive >> FishEngine::make_nvp("m_shadowNearPlane", m_shadowNearPlane); // float
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Light::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Light>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Behaviour::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_type, ret->m_type); // FishEngine::LightType
		FishEngine::CloneUtility::Clone(this->m_range, ret->m_range); // float
		FishEngine::CloneUtility::Clone(this->m_spotAngle, ret->m_spotAngle); // float
		FishEngine::CloneUtility::Clone(this->m_color, ret->m_color); // FishEngine::Color
		FishEngine::CloneUtility::Clone(this->m_intensity, ret->m_intensity); // float
		FishEngine::CloneUtility::Clone(this->m_shadowBias, ret->m_shadowBias); // float
		FishEngine::CloneUtility::Clone(this->m_shadowNormalBias, ret->m_shadowNormalBias); // float
		FishEngine::CloneUtility::Clone(this->m_shadowNearPlane, ret->m_shadowNearPlane); // float
		return ret;
	}

	void FishEngine::Light::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Behaviour::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Light>(target);
		FishEngine::CloneUtility::Clone(this->m_type, ptr->m_type); // FishEngine::LightType
		FishEngine::CloneUtility::Clone(this->m_range, ptr->m_range); // float
		FishEngine::CloneUtility::Clone(this->m_spotAngle, ptr->m_spotAngle); // float
		FishEngine::CloneUtility::Clone(this->m_color, ptr->m_color); // FishEngine::Color
		FishEngine::CloneUtility::Clone(this->m_intensity, ptr->m_intensity); // float
		FishEngine::CloneUtility::Clone(this->m_shadowBias, ptr->m_shadowBias); // float
		FishEngine::CloneUtility::Clone(this->m_shadowNormalBias, ptr->m_shadowNormalBias); // float
		FishEngine::CloneUtility::Clone(this->m_shadowNearPlane, ptr->m_shadowNearPlane); // float
	}


	// FishEngine::Texture2D
	void FishEngine::Texture2D::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Texture::Serialize(archive);
		archive << FishEngine::make_nvp("m_format", m_format); // FishEngine::TextureFormat
		archive << FishEngine::make_nvp("m_mipmapCount", m_mipmapCount); // uint32_t
		//archive.EndClass();
	}

	void FishEngine::Texture2D::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Texture::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_format", m_format); // FishEngine::TextureFormat
		archive >> FishEngine::make_nvp("m_mipmapCount", m_mipmapCount); // uint32_t
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Texture2D::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Texture2D>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Texture::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_format, ret->m_format); // FishEngine::TextureFormat
		FishEngine::CloneUtility::Clone(this->m_mipmapCount, ret->m_mipmapCount); // uint32_t
		return ret;
	}

	void FishEngine::Texture2D::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Texture::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Texture2D>(target);
		FishEngine::CloneUtility::Clone(this->m_format, ptr->m_format); // FishEngine::TextureFormat
		FishEngine::CloneUtility::Clone(this->m_mipmapCount, ptr->m_mipmapCount); // uint32_t
	}


	// FishEngine::Avatar
	void FishEngine::Avatar::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_boneToIndex", m_boneToIndex); // std::map<std::string, int>
		archive << FishEngine::make_nvp("m_indexToBone", m_indexToBone); // std::map<int, std::string>
		archive << FishEngine::make_nvp("m_matrixPalette", m_matrixPalette); // std::vector<Matrix4x4>
		//archive.EndClass();
	}

	void FishEngine::Avatar::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_boneToIndex", m_boneToIndex); // std::map<std::string, int>
		archive >> FishEngine::make_nvp("m_indexToBone", m_indexToBone); // std::map<int, std::string>
		archive >> FishEngine::make_nvp("m_matrixPalette", m_matrixPalette); // std::vector<Matrix4x4>
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Avatar::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Avatar>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Object::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_boneToIndex, ret->m_boneToIndex); // std::map<std::string, int>
		FishEngine::CloneUtility::Clone(this->m_indexToBone, ret->m_indexToBone); // std::map<int, std::string>
		FishEngine::CloneUtility::Clone(this->m_matrixPalette, ret->m_matrixPalette); // std::vector<Matrix4x4>
		return ret;
	}

	void FishEngine::Avatar::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Object::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Avatar>(target);
		FishEngine::CloneUtility::Clone(this->m_boneToIndex, ptr->m_boneToIndex); // std::map<std::string, int>
		FishEngine::CloneUtility::Clone(this->m_indexToBone, ptr->m_indexToBone); // std::map<int, std::string>
		FishEngine::CloneUtility::Clone(this->m_matrixPalette, ptr->m_matrixPalette); // std::vector<Matrix4x4>
	}


	// FishEngine::Script
	void FishEngine::Script::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Behaviour::Serialize(archive);
		//archive.EndClass();
	}

	void FishEngine::Script::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Behaviour::Deserialize(archive);
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Script::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Script>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Behaviour::CopyValueTo(obj);
		return ret;
	}

	void FishEngine::Script::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Behaviour::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Script>(target);
	}


	// FishEngine::Int4
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Int4 const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("x", value.x); // int
		archive << FishEngine::make_nvp("y", value.y); // int
		archive << FishEngine::make_nvp("z", value.z); // int
		archive << FishEngine::make_nvp("w", value.w); // int
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Int4 & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("x", value.x); // int
		archive >> FishEngine::make_nvp("y", value.y); // int
		archive >> FishEngine::make_nvp("z", value.z); // int
		archive >> FishEngine::make_nvp("w", value.w); // int
		archive.EndClass();
		return archive;
	}

	// FishEngine::Frustum
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Frustum const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("fov", value.fov); // float
		archive << FishEngine::make_nvp("maxRange", value.maxRange); // float
		archive << FishEngine::make_nvp("minRange", value.minRange); // float
		archive << FishEngine::make_nvp("aspect", value.aspect); // float
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Frustum & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("fov", value.fov); // float
		archive >> FishEngine::make_nvp("maxRange", value.maxRange); // float
		archive >> FishEngine::make_nvp("minRange", value.minRange); // float
		archive >> FishEngine::make_nvp("aspect", value.aspect); // float
		archive.EndClass();
		return archive;
	}

	// FishEngine::Int3
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Int3 const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("x", value.x); // int
		archive << FishEngine::make_nvp("y", value.y); // int
		archive << FishEngine::make_nvp("z", value.z); // int
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Int3 & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("x", value.x); // int
		archive >> FishEngine::make_nvp("y", value.y); // int
		archive >> FishEngine::make_nvp("z", value.z); // int
		archive.EndClass();
		return archive;
	}

	// FishEngine::Int2
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Int2 const & value )
	{
		archive.BeginClass();
		archive << FishEngine::make_nvp("x", value.x); // int
		archive << FishEngine::make_nvp("y", value.y); // int
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Int2 & value )
	{
		archive.BeginClass();
		archive >> FishEngine::make_nvp("x", value.x); // int
		archive >> FishEngine::make_nvp("y", value.y); // int
		archive.EndClass();
		return archive;
	}

	// FishEngine::Camera
	void FishEngine::Camera::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Behaviour::Serialize(archive);
		archive << FishEngine::make_nvp("m_fieldOfView", m_fieldOfView); // float
		archive << FishEngine::make_nvp("m_orthographicSize", m_orthographicSize); // float
		archive << FishEngine::make_nvp("m_aspect", m_aspect); // float
		archive << FishEngine::make_nvp("m_isAspectSet", m_isAspectSet); // bool
		archive << FishEngine::make_nvp("m_farClipPlane", m_farClipPlane); // float
		archive << FishEngine::make_nvp("m_nearClipPlane", m_nearClipPlane); // float
		archive << FishEngine::make_nvp("m_viewport", m_viewport); // FishEngine::Vector4
		archive << FishEngine::make_nvp("m_isDirty", m_isDirty); // bool
		archive << FishEngine::make_nvp("m_cameraType", m_cameraType); // FishEngine::CameraType
		archive << FishEngine::make_nvp("m_orthographic", m_orthographic); // bool
		//archive.EndClass();
	}

	void FishEngine::Camera::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Behaviour::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_fieldOfView", m_fieldOfView); // float
		archive >> FishEngine::make_nvp("m_orthographicSize", m_orthographicSize); // float
		archive >> FishEngine::make_nvp("m_aspect", m_aspect); // float
		archive >> FishEngine::make_nvp("m_isAspectSet", m_isAspectSet); // bool
		archive >> FishEngine::make_nvp("m_farClipPlane", m_farClipPlane); // float
		archive >> FishEngine::make_nvp("m_nearClipPlane", m_nearClipPlane); // float
		archive >> FishEngine::make_nvp("m_viewport", m_viewport); // FishEngine::Vector4
		archive >> FishEngine::make_nvp("m_isDirty", m_isDirty); // bool
		archive >> FishEngine::make_nvp("m_cameraType", m_cameraType); // FishEngine::CameraType
		archive >> FishEngine::make_nvp("m_orthographic", m_orthographic); // bool
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Camera::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Camera>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Behaviour::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_fieldOfView, ret->m_fieldOfView); // float
		FishEngine::CloneUtility::Clone(this->m_orthographicSize, ret->m_orthographicSize); // float
		FishEngine::CloneUtility::Clone(this->m_aspect, ret->m_aspect); // float
		FishEngine::CloneUtility::Clone(this->m_isAspectSet, ret->m_isAspectSet); // bool
		FishEngine::CloneUtility::Clone(this->m_farClipPlane, ret->m_farClipPlane); // float
		FishEngine::CloneUtility::Clone(this->m_nearClipPlane, ret->m_nearClipPlane); // float
		FishEngine::CloneUtility::Clone(this->m_viewport, ret->m_viewport); // FishEngine::Vector4
		FishEngine::CloneUtility::Clone(this->m_isDirty, ret->m_isDirty); // bool
		FishEngine::CloneUtility::Clone(this->m_cameraType, ret->m_cameraType); // FishEngine::CameraType
		FishEngine::CloneUtility::Clone(this->m_orthographic, ret->m_orthographic); // bool
		return ret;
	}

	void FishEngine::Camera::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Behaviour::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Camera>(target);
		FishEngine::CloneUtility::Clone(this->m_fieldOfView, ptr->m_fieldOfView); // float
		FishEngine::CloneUtility::Clone(this->m_orthographicSize, ptr->m_orthographicSize); // float
		FishEngine::CloneUtility::Clone(this->m_aspect, ptr->m_aspect); // float
		FishEngine::CloneUtility::Clone(this->m_isAspectSet, ptr->m_isAspectSet); // bool
		FishEngine::CloneUtility::Clone(this->m_farClipPlane, ptr->m_farClipPlane); // float
		FishEngine::CloneUtility::Clone(this->m_nearClipPlane, ptr->m_nearClipPlane); // float
		FishEngine::CloneUtility::Clone(this->m_viewport, ptr->m_viewport); // FishEngine::Vector4
		FishEngine::CloneUtility::Clone(this->m_isDirty, ptr->m_isDirty); // bool
		FishEngine::CloneUtility::Clone(this->m_cameraType, ptr->m_cameraType); // FishEngine::CameraType
		FishEngine::CloneUtility::Clone(this->m_orthographic, ptr->m_orthographic); // bool
	}


	// FishEngine::Scene
	FishEngine::OutputArchive & operator << ( FishEngine::OutputArchive & archive, FishEngine::Scene const & value )
	{
		archive.BeginClass();
		archive.EndClass();
		return archive;
	}

	FishEngine::InputArchive & operator >> ( FishEngine::InputArchive & archive, FishEngine::Scene & value )
	{
		archive.BeginClass();
		archive.EndClass();
		return archive;
	}

	// FishEngine::MeshRenderer
	void FishEngine::MeshRenderer::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Renderer::Serialize(archive);
		//archive.EndClass();
	}

	void FishEngine::MeshRenderer::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Renderer::Deserialize(archive);
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::MeshRenderer::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::MeshRenderer>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Renderer::CopyValueTo(obj);
		return ret;
	}

	void FishEngine::MeshRenderer::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Renderer::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::MeshRenderer>(target);
	}


	// FishEngine::Transform
	void FishEngine::Transform::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Component::Serialize(archive);
		archive << FishEngine::make_nvp("m_localPosition", m_localPosition); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_localScale", m_localScale); // FishEngine::Vector3
		archive << FishEngine::make_nvp("m_localRotation", m_localRotation); // FishEngine::Quaternion
		archive << FishEngine::make_nvp("m_parent", m_parent); // std::weak_ptr<Transform>
		archive << FishEngine::make_nvp("m_children", m_children); // std::list<std::weak_ptr<Transform> >
		//archive.EndClass();
	}

	void FishEngine::Transform::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Component::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_localPosition", m_localPosition); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_localScale", m_localScale); // FishEngine::Vector3
		archive >> FishEngine::make_nvp("m_localRotation", m_localRotation); // FishEngine::Quaternion
		archive >> FishEngine::make_nvp("m_parent", m_parent); // std::weak_ptr<Transform>
		archive >> FishEngine::make_nvp("m_children", m_children); // std::list<std::weak_ptr<Transform> >
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::Transform::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::Transform>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Component::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_localPosition, ret->m_localPosition); // FishEngine::Vector3
		FishEngine::CloneUtility::Clone(this->m_localScale, ret->m_localScale); // FishEngine::Vector3
		FishEngine::CloneUtility::Clone(this->m_localRotation, ret->m_localRotation); // FishEngine::Quaternion
		FishEngine::CloneUtility::Clone(this->m_parent, ret->m_parent); // std::weak_ptr<Transform>
		FishEngine::CloneUtility::Clone(this->m_children, ret->m_children); // std::list<std::weak_ptr<Transform> >
		return ret;
	}

	void FishEngine::Transform::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Component::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::Transform>(target);
		FishEngine::CloneUtility::Clone(this->m_localPosition, ptr->m_localPosition); // FishEngine::Vector3
		FishEngine::CloneUtility::Clone(this->m_localScale, ptr->m_localScale); // FishEngine::Vector3
		FishEngine::CloneUtility::Clone(this->m_localRotation, ptr->m_localRotation); // FishEngine::Quaternion
		FishEngine::CloneUtility::Clone(this->m_parent, ptr->m_parent); // std::weak_ptr<Transform>
		FishEngine::CloneUtility::Clone(this->m_children, ptr->m_children); // std::list<std::weak_ptr<Transform> >
	}


	// FishEngine::GameObject
	void FishEngine::GameObject::Serialize ( FishEngine::OutputArchive & archive ) const
	{
		//archive.BeginClass();
		FishEngine::Object::Serialize(archive);
		archive << FishEngine::make_nvp("m_components", m_components); // std::list<ComponentPtr>
		archive << FishEngine::make_nvp("m_activeSelf", m_activeSelf); // bool
		archive << FishEngine::make_nvp("m_layer", m_layer); // int
		archive << FishEngine::make_nvp("m_tagIndex", m_tagIndex); // int
		archive << FishEngine::make_nvp("m_transform", m_transform); // TransformPtr
		//archive.EndClass();
	}

	void FishEngine::GameObject::Deserialize ( FishEngine::InputArchive & archive )
	{
		//archive.BeginClass(2);
		FishEngine::Object::Deserialize(archive);
		archive >> FishEngine::make_nvp("m_components", m_components); // std::list<ComponentPtr>
		archive >> FishEngine::make_nvp("m_activeSelf", m_activeSelf); // bool
		archive >> FishEngine::make_nvp("m_layer", m_layer); // int
		archive >> FishEngine::make_nvp("m_tagIndex", m_tagIndex); // int
		archive >> FishEngine::make_nvp("m_transform", m_transform); // TransformPtr
		//archive.EndClass();
	}

	FishEngine::ObjectPtr FishEngine::GameObject::Clone() const
	{
		auto ret = FishEngine::MakeShared<FishEngine::GameObject>();
		FishEngine::ObjectPtr obj = ret;
		FishEngine::Object::CopyValueTo(obj);
		FishEngine::CloneUtility::Clone(this->m_components, ret->m_components); // std::list<ComponentPtr>
		FishEngine::CloneUtility::Clone(this->m_activeSelf, ret->m_activeSelf); // bool
		FishEngine::CloneUtility::Clone(this->m_layer, ret->m_layer); // int
		FishEngine::CloneUtility::Clone(this->m_tagIndex, ret->m_tagIndex); // int
		FishEngine::CloneUtility::Clone(this->m_transform, ret->m_transform); // TransformPtr
		return ret;
	}

	void FishEngine::GameObject::CopyValueTo(ObjectPtr & target) const
	{
		FishEngine::Object::CopyValueTo(target);
		auto ptr = std::dynamic_pointer_cast<FishEngine::GameObject>(target);
		FishEngine::CloneUtility::Clone(this->m_components, ptr->m_components); // std::list<ComponentPtr>
		FishEngine::CloneUtility::Clone(this->m_activeSelf, ptr->m_activeSelf); // bool
		FishEngine::CloneUtility::Clone(this->m_layer, ptr->m_layer); // int
		FishEngine::CloneUtility::Clone(this->m_tagIndex, ptr->m_tagIndex); // int
		FishEngine::CloneUtility::Clone(this->m_transform, ptr->m_transform); // TransformPtr
	}


} // namespace FishEngine
