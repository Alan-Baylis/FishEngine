#pragma Normalmap Off
#pragma Shadow Off
#include <UnrealSupport.inc>
#include <BRDF.inc>
#include <Ambient.inc>


uniform vec3  BaseColor;
uniform float Metallic;
uniform float Roughness;
uniform float Specular;

//#define _AMBIENT_IBL 1
//uniform samplerCube AmbientCubemap;
//uniform samplerCube IrradianceMap;

struct PixelMaterialInputs
{
    vec3 BaseColor;
    float Metallic;
    float Roughness;
    float Specular;
};

#ifdef NO_DEFAULT_MATERIAL 
    PixelMaterialInputs CalcPixelMaterialInputs(in SurfaceData s);
#else
    PixelMaterialInputs CalcPixelMaterialInputs(in SurfaceData s)
    {
        PixelMaterialInputs inputs;

        inputs.BaseColor = BaseColor;
        inputs.Metallic = Metallic;
        inputs.Roughness = Roughness;
        inputs.Specular = Specular;
        return inputs;
    }
#endif

#if 0

vec4 ps_main(SurfaceData surfaceData)
{
    //PixelMaterialInputs i = CalcPixelMaterialInputs(surfaceData);
    vec4 outColor;
    vec3 L = surfaceData.L;
    vec3 V = surfaceData.V;
    vec3 N = surfaceData.N;
    vec3 DiffuseColor = BaseColor - BaseColor * Metallic;
    vec3 SpecularColor = mix( vec3(0.08 * Specular), BaseColor, Metallic);
#if 0
    float NoL = saturate( dot(N, L) );
    outColor.rgb = PI * LightColor0.rgb * NoL * StandardShading(DiffuseColor, SpecularColor, vec3(Roughness), vec3(1), L, V, N, vec2(1));
#endif

#ifdef _AMBIENT_IBL
#if 0
    float NoV = saturate( abs( dot(N, V) ) + 1e-5 );
    const int numMips   = 6;
    float mip           = numMips - 1 + log2(Roughness);
    vec3 lookup         = -reflect(V, N);
    //lookup              = fix_cube_lookup(lookup, 512, mip);
    //vec3 radiance       = pow(textureLod(RadianceMap, lookup, mip).rgb, vec3(2.2));
    //vec3 irradiance     = pow(texture(IrradianceMap, N).rgb, vec3(2.2));
    vec3 radiance       = textureLod(AmbientCubemap, lookup, mip).rgb;
    vec3 irradiance     = textureLod(IrradianceMap, N, 0).rgb;

    vec3 reflectance    = EnvBRDFApprox(SpecularColor, Roughness, NoV);
    vec3 diffuse        = DiffuseColor * irradiance;
    vec3 specular       = radiance * reflectance;
    //outColor.rgb       += pow(diffuse + specular, vec3(1.0/2.2));
    outColor.rgb        += diffuse + specular;
#else
    uint2 seed = uint2(uint(abs(310103671 * surfaceData.uv.y)), uint(abs(310103671 * surfaceData.uv.x)));
    seed = ScrambleTEA(seed);
    outColor.rgb  = ApproximateSpecularIBL(seed, SpecularColor, Roughness, N, V);
#endif
#endif
    //outColor.rgb = vec3(0.5f);
    outColor.a = 1.0f;
    return outColor;
}

#elif 0

vec4 ps_main(SurfaceData surfaceData)
{
    vec4 outColor;
    vec3 L = surfaceData.L;
    vec3 V = surfaceData.V;
    vec3 N = surfaceData.N;

    vec3 DiffuseColor = BaseColor - BaseColor * Metallic;
    vec3 SpecularColor = mix( vec3(0.08 * Specular), BaseColor, Metallic);
    float NoL = saturate( dot(N, L) );

    //outColor.rgb = PI * LightColor0.rgb * NoL * StandardShading(DiffuseColor, SpecularColor, vec3(Roughness, Roughness, Roughness), vec3(1), L, V, N, vec2(1));
    uint2 seed = uint2(uint(abs(310103671 * surfaceData.uv.y)), uint(abs(310103671 * surfaceData.uv.x)));
    seed = ScrambleTEA(seed);
    //outColor.rgb  = SpecularIBL(seed, SpecularColor, Roughness, N, V);
    outColor.rgb = ApproximateSpecularIBL(seed, SpecularColor, Roughness, N, V);
    //outColor.rgb += DiffuseIBL(seed, DiffuseColor, Roughness, N, V);
    outColor.a = 1;
    return outColor;
}

#else

vec4 ps_main(SurfaceData surfaceData)
{
    vec4 outColor;
    vec3 L = surfaceData.L;
    vec3 V = surfaceData.V;
    vec3 N = surfaceData.N;
    float3 R0 = 2 * dot( V, N ) * N - V;

    vec3 DiffuseColor = BaseColor - BaseColor * Metallic;
    vec3 SpecularColor = mix( vec3(0.08 * Specular), BaseColor, Metallic);
    float NoL = saturate( dot(N, L) );
    //float NoV = max( dot(N, V), 1e-5 );
    float NoV = saturate( dot(N, V) );
    // Point lobe in off-specular peak direction
    float a = Square( Roughness );
    float3 R = lerp( N, R0, (1 - a) * ( sqrt(1 - a) + a ) );
    
    float Mip = ComputeCubemapMipFromRoughness(Roughness, AmbientCubemapMipAdjust.w);
    float3 SampleColor = textureLod(AmbientCubemap, R, Mip).rgb;
    float3 SpecularContribution = SampleColor * EnvBRDFApprox(SpecularColor, Roughness, NoV);

    outColor.rgb = SpecularContribution;
    // //outColor.rgb = PI * LightColor0.rgb * NoL * StandardShading(DiffuseColor, SpecularColor, vec3(Roughness, Roughness, Roughness), vec3(1), L, V, N, vec2(1));
    // uint2 seed = uint2(uint(abs(31010367 * surfaceData.uv.y)), uint(abs(10103671 * surfaceData.uv.x)));
    // seed = ScrambleTEA(seed);
    // //outColor.rgb  = SpecularIBL(seed, SpecularColor, Roughness, N, V);
    // outColor.rgb = ApproximateSpecularIBL(seed, SpecularColor, Roughness, N, V);
    // //outColor.rgb += DiffuseIBL(seed, DiffuseColor, Roughness, N, V);
    outColor.a = 1;
    return outColor;
}

#endif
