#pragma Normalmap Off
#pragma Shadow Off
#include <UnrealSupport.inc>
#include <BRDF.inc>

uniform vec3  BaseColor;
uniform float Metallic;
uniform float Roughness;
uniform float Specular;

//#define _AMBIENT_IBL 1
uniform samplerCube AmbientCubemap;
uniform samplerCube IrradianceMap;

struct PixelMaterialInputs
{
    vec3 BaseColor;
    float Metallic;
    float Roughness;
    float Specular;
};

#ifdef NO_DEFAULT_MATERIAL 
    PixelMaterialInputs CalcPixelMaterialInputs(in SurfaceData s);
#else
    PixelMaterialInputs CalcPixelMaterialInputs(in SurfaceData s)
    {
        PixelMaterialInputs inputs;

        inputs.BaseColor = BaseColor;
        inputs.Metallic = Metallic;
        inputs.Roughness = Roughness;
        inputs.Specular = Specular;
        return inputs;
    }
#endif

// // http://the-witness.net/news/2012/02/seamless-cube-map-filtering/
// vec3 fix_cube_lookup( vec3 v, float cube_size, float lod )
// {
//     float M = max(max(abs(v.x), abs(v.y)), abs(v.z));
//     float scale = 1 - exp2(lod) / cube_size;
//     if (abs(v.x) != M) v.x *= scale;
//     if (abs(v.y) != M) v.y *= scale;
//     if (abs(v.z) != M) v.z *= scale;
//     return v;
// }

//#ifdef _AMBIENT_IBL
float3 PrefilterEnvMap( uint2 Random, float Roughness, float3 R )
{
    float3 FilteredColor = float3(0);
    float Weight = 0;
        
    const uint NumSamples = 64;
    for( uint i = 0; i < NumSamples; i++ )
    {
        float2 E = Hammersley( i, NumSamples, Random );
        float3 H = TangentToWorld( ImportanceSampleGGX( E, Roughness ).xyz, R );
        float3 L = 2 * dot( R, H ) * H - R;

        float NoL = saturate( dot( R, L ) );
        if( NoL > 0 )
        {
            //FilteredColor += AmbientCubemap.SampleLevel( AmbientCubemapSampler, L, 0 ).rgb * NoL;
            FilteredColor = textureLod(AmbientCubemap, L, 0).rgb * NoL;
            Weight += NoL;
        }
    }

    return FilteredColor / max( Weight, 0.001 );
}
//#endif

float3 IntegrateBRDF( uint2 Random, float Roughness, float NoV )
{
    float3 V;
    V.x = sqrt( 1.0f - NoV * NoV ); // sin
    V.y = 0;
    V.z = NoV;                      // cos

    float A = 0;
    float B = 0;
    float C = 0;

    const uint NumSamples = 64;
    for( uint i = 0; i < NumSamples; i++ )
    {
        float2 E = Hammersley( i, NumSamples, Random );

        {
            float3 H = ImportanceSampleGGX( E, Roughness ).xyz;
            float3 L = 2 * dot( V, H ) * H - V;

            float NoL = saturate( L.z );
            float NoH = saturate( H.z );
            float VoH = saturate( dot( V, H ) );

            if( NoL > 0 )
            {
                float Vis = Vis_SmithJointApprox( Roughness, NoV, NoL );

                float a = Square( Roughness );
                float a2 = a*a;
                float Vis_SmithV = NoL * sqrt( NoV * (NoV - NoV * a2) + a2 );
                float Vis_SmithL = NoV * sqrt( NoL * (NoL - NoL * a2) + a2 );
                //float Vis = 0.5 * rcp( Vis_SmithV + Vis_SmithL );

                // Incident light = NoL
                // pdf = D * NoH / (4 * VoH)
                // NoL * Vis / pdf
                float NoL_Vis_PDF = NoL * Vis * (4 * VoH / NoH);

                float Fc = pow( 1 - VoH, 5 );
                A += (1 - Fc) * NoL_Vis_PDF;
                B += Fc * NoL_Vis_PDF;
            }
        }

        {
            float3 L = CosineSampleHemisphere( E ).xyz;
            float3 H = normalize(V + L);

            float NoL = saturate( L.z );
            float NoH = saturate( H.z );
            float VoH = saturate( dot( V, H ) );

            float FD90 = ( 0.5 + 2 * VoH * VoH ) * Roughness;
            float FdV = 1 + (FD90 - 1) * pow( 1 - NoV, 5 );
            float FdL = 1 + (FD90 - 1) * pow( 1 - NoL, 5 );
            C += FdV * FdL * ( 1 - 0.3333 * Roughness );
        }
    }

    return float3( A, B, C ) / NumSamples;
}

float3 ApproximateSpecularIBL( uint2 Random, float3 SpecularColor, float Roughness, float3 N, float3 V )
{
    // Function replaced with prefiltered environment map sample
    float3 R = 2 * dot( V, N ) * N - V;
    float3 PrefilteredColor = PrefilterEnvMap( Random, Roughness, R );
    //float3 PrefilteredColor = FilterEnvMap( Random, Roughness, N, V );

    // Function replaced with 2D texture sample
    float NoV = saturate( dot( N, V ) );
    float2 AB = IntegrateBRDF( Random, Roughness, NoV ).xy;

    return PrefilteredColor * ( SpecularColor * AB.x + AB.y );
}

vec4 ps_main(SurfaceData surfaceData)
{
    //PixelMaterialInputs i = CalcPixelMaterialInputs(surfaceData);
    vec4 outColor;
    vec3 L = surfaceData.L;
    vec3 V = surfaceData.V;
    vec3 N = surfaceData.N;
    vec3 DiffuseColor = BaseColor - BaseColor * Metallic;
    vec3 SpecularColor = mix( vec3(0.08 * Specular), BaseColor, Metallic);
#if 0
    float NoL = saturate( dot(N, L) );
    outColor.rgb = PI * LightColor0.rgb * NoL * StandardShading(DiffuseColor, SpecularColor, vec3(Roughness), vec3(1), L, V, N, vec2(1));
#endif

#ifdef _AMBIENT_IBL
#if 0
    float NoV = saturate( abs( dot(N, V) ) + 1e-5 );
    const int numMips   = 6;
    float mip           = numMips - 1 + log2(Roughness);
    vec3 lookup         = -reflect(V, N);
    //lookup              = fix_cube_lookup(lookup, 512, mip);
    //vec3 radiance       = pow(textureLod(RadianceMap, lookup, mip).rgb, vec3(2.2));
    //vec3 irradiance     = pow(texture(IrradianceMap, N).rgb, vec3(2.2));
    vec3 radiance       = textureLod(AmbientCubemap, lookup, mip).rgb;
    vec3 irradiance     = textureLod(IrradianceMap, N, 0).rgb;

    vec3 reflectance    = EnvBRDFApprox(SpecularColor, Roughness, NoV);
    vec3 diffuse        = DiffuseColor * irradiance;
    vec3 specular       = radiance * reflectance;
    //outColor.rgb       += pow(diffuse + specular, vec3(1.0/2.2));
    outColor.rgb        += diffuse + specular;
#else
    uint2 seed = uint2(uint(abs(310103671 * surfaceData.uv.y)), uint(abs(310103671 * surfaceData.uv.x)));
    seed = ScrambleTEA(seed);
    outColor.rgb  = ApproximateSpecularIBL(seed, SpecularColor, Roughness, N, V);
#endif
#endif
    //outColor.rgb = vec3(0.5f);
    outColor.a = 1.0f;
    return outColor;
}
